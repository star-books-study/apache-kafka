# Chapter 03. 카프카 기본 개념 설명

## 3.1 카프카 브로커 / 클러스터 / 주키퍼

- 카프카 브로커는 카르카 클라이언트와 데이터를 주고받기 위해 사용하는 주체이자, 데이터를 분산 저장하여 장애가 발생해도 안전하게 사용할 수 있도록 도와주는 애플리케이션
- 하나의 서버에는 한 개의 카프카 브로커 프로세스가 실행됨
- 한 대로도 기본 기능이 실행되지만 안전하게 보관하고 처리하기 위해 3대 이상의 브로커 서버를 1개의 클러스터로 묶어서 운영
- 카프카 클러스터로 묶인 브로커들은 프로듀서가 보낸 데이터를 안전하게 분산 저장하고 복제

<img src="https://github.com/user-attachments/assets/a5234784-c63f-4365-8dba-d3bc000ceae2" />

### 데이터 저장, 전송
- 프로듀서로부터 데이터를 전달받으면 카프카 브로커는 프로듀서가 요청한 토픽의 파티션에 데이터를 저장하고 컨슈머가 데이터를 요청하면 파티션에 저장된 데이터를 전달한다.
- 프로듀서로부터 전달된 데이터는 파일 시스템에 저장된다.

```bash
$ ls /tmp/kafka-logs 


$ ls /tmp/kafka-logs/hello.kafka-0
```
- 카프카는 메모리나 데이터베이스에 저장하지 않으며 따로 캐시 메모리를 구현하여 사용하지도 않는다. 파일 시스템에 저장하기 때문에 속도 이슈가 발생하지 않을까 의문을 가질 수도 있다.
- 카프카는 페이지 캐시를 사용해 디스크 입출력 속도를 높여 이 문제를 해결했다.
  - 페이지 캐시 : OS에서 파일 입출력의 성능 향상을 위해 만들어 놓은 메모리 영역

### 데이터 복제, 싱크
- 데이터 복제는 카프카를 장애 허용 시스템으로 동작하도록 하는 원동력
- 데이터 복제는 파티션 단위로 이루어진다.


![image](https://github.com/user-attachments/assets/ce7f3391-86b1-4876-8cc2-7e15ce56d7fd)


- 복제 개수의 최솟값은 1(복제 없음), 최댓값은 브로커 개수만큼 설정하여 사용 가능
- 다음은 복제 개수가 3인 경우이다. 복제된 파티션은 리더와 팔로워로 구성된다.
  - 리더 : 프로듀서 또는 컨슈머와 직접 통신
  - 팔로워 : 나머지 복제 데이터를 가지고 있는 파티션

- 팔로워 파티션들은 리더 파티션의 오프셋을 확인하여 현재 자신이 가지고 있는 오프셋과 차이가 나는 경우 리더 파티션으로부터 데이터를 가져와 자신의 파티션에 저장 => 이것이 바로 "복제"!
- 복제되면 저장 용량이 증가하지만 안전하게 사용할 수 있음 (2 이상의 복재 개수를 정하는 것이 중요)
- 안정성이 좋지만 서버는 언제든 장애가 발생할 수 있음

![image](https://github.com/user-attachments/assets/0e23d909-754a-40a7-a72e-115423380865)

#### 컨트롤러
- 다수 브로커 중 한 대가 컨트롤러의 역할을 한다.
